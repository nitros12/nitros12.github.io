<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on ~simmsb</title><link>/tags/python/</link><description>Recent content in python on ~simmsb</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Wed, 20 Mar 2019 00:00:00 +0000</lastBuildDate><atom:link href="/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Writing our own event loops in python</title><link>/writing-our-own-event-loops-in-python/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>/writing-our-own-event-loops-in-python/</guid><description>One of the good features of python is it&amp;rsquo;s native support for coroutines, generalised functions that can be paused and resumed, allowing objects to be passed between the coroutine and whoever is running them when at the time.
The most widely used place for Python&amp;rsquo;s coroutines currently is in asyncio frameworks, namely the standard library module: AsyncIO, Trio, and Curio. These use python coroutines to allow the user to write code that requires IO resources that may not be available at some point when their code runs, but will be in the future.</description></item></channel></rss>