<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>~simmsb</title><link>/</link><description>Recent content on ~simmsb</description><generator>Hugo -- gohugo.io</generator><language>en-uk</language><lastBuildDate>Fri, 24 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Writing a discord library using Polysemy</title><link>/writing-a-discord-library-using-polysemy/</link><pubDate>Fri, 24 Apr 2020 00:00:00 +0000</pubDate><guid>/writing-a-discord-library-using-polysemy/</guid><description>Recently I&amp;rsquo;ve migrated my discord library from mtl/transformers to polysemy after reading as many blog posts as I could find on it. My main reasons for wanting to migrate were escaping from having to write newtypes and all N instances every time I had a more than one effect in my stack, and how little boilerplate polysemy requires to write new effects.
In this1 and some upcoming blog post I&amp;rsquo;ll be writing about the challenges I faced and solved2 while going about the conversion.</description></item><item><title>Writing our own event loops in python</title><link>/writing-our-own-event-loops-in-python/</link><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><guid>/writing-our-own-event-loops-in-python/</guid><description>One of the good features of python is it&amp;rsquo;s native support for coroutines, generalised functions that can be paused and resumed, allowing objects to be passed between the coroutine and whoever is running them when at the time.
The most widely used place for Python&amp;rsquo;s coroutines currently is in asyncio frameworks, namely the standard library module: AsyncIO, Trio, and Curio. These use python coroutines to allow the user to write code that requires IO resources that may not be available at some point when their code runs, but will be in the future.</description></item></channel></rss>